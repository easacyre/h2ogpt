#!/usr/bin/groovy

@Library('test-shared-library@dai_pipeline') _

import ai.h2o.ci.buildsummary.StagesSummary
import groovy.json.JsonOutput

buildSummary('https://github.com/h2ogpt', true)
buildSummary.get().addStagesSummary(this, new StagesSummary())

def ALL_TESTS = [
        //"test_osx_py_3_10":  [ install_deps: "ALL", test_target: "test", node: "osx", use_docker: false, env: ['PYTHON_BINARY=/Users/jenkins/anaconda/envs/h2ogpt-py3.10/bin/python'] ],
        "test_dl24_py_3_10": [ install_deps: "ALL,4BIT", test_target: "test", node: "mr-dl24", use_docker: true, env: [] ],
]

pipeline {
    agent none
    parameters {
        booleanParam(name: 'skipTesting', defaultValue: false, description: 'Skip testing')
        text(name: "testTargets", defaultValue: "${ALL_TESTS.keySet().join('\n')}", description: "A select set of tests to run")
        booleanParam(name: 'publish', defaultValue: false, description: 'Upload to HF')
    }
    options {
        ansiColor('xterm')
        timestamps()
        timeout(time: 60, unit: 'MINUTES')
    }
    stages {
        stage('Build') {
            agent {
                label "linux && docker"
            }
            steps {
                script {
                    // def docker_image = sh(returnStdout: true, script: "make print-DOCKER_TEST_IMAGE").trim()
                    sh "make docker_build"
                    sh "SKIP_BUILD=1 make run_in_docker"
                    archiveArtifacts allowEmptyArchive: true, artifacts: "dist/h2ogpt-*.whl"
                    stash includes: "dist/h2ogpt-*.whl", name: "wheel_file"
                }
            }
        }

        stage('Tests') {
            when {
                anyOf {
                    expression { return !params.skipTesting }
                }
                beforeAgent true
            }
            agent {
                label "linux && docker"
            }
            steps {
                script {
                    def test_targets = [:]
                    params.testTargets.split('\n').findAll{ it.contains("test_") }.each { test_name ->
                        test_targets[test_name] = {
                            node("${ALL_TESTS[test_name].node}") {
                                buildSummary.stageWithSummary("${test_name}", "${test_name}") {
                                    buildSummary.setStageUrl("${test_name}")
                                    script {
                                        try {
                                            dir("${test_name}") {
                                                withEnv(
                                                ALL_TESTS[test_name].env +
                                                [
                                                    "PYTEST_TEST_NAME=_${test_name}",
                                                    "IS_PR_BUILD=${isPrBranch()}",
                                                    "BUILD_NUMBER=${env.BUILD_ID}",
                                                    "BUILD_BASE_NAME=${env.JOB_BASE_NAME}"
                                                ]) {
                                                    deleteDir()
                                                    checkout scm
                                                    unstash "wheel_file"
                                                    sh "rm -rf *.py spaces models"  // force the imports from installed wheel
                                                    if (ALL_TESTS[test_name].use_docker) {
                                                        sh "BUILD_NUMBER=${env.BUILD_ID} SKIP_BUILD=1 CMD_TO_RUN_IN_DOCKER='make install-${ALL_TESTS[test_name].install_deps} ${ALL_TESTS[test_name].test_target}' make run_in_docker"
                                                    } else {
                                                        sh "make venv"  // setup empty test env
                                                        sh "PYTHON_BINARY=`pwd`/venv/bin/python make install-${ALL_TESTS[test_name].install_deps}"
                                                        sh "PYTHON_BINARY=`pwd`/venv/bin/python make ${ALL_TESTS[test_name].test_target}"
                                                    }
                                                }
                                            }
                                        } finally {
                                            sh "mv ${test_name}/test_report.xml ${test_name}/${test_name}_report.xml"
                                            archiveArtifacts allowEmptyArchive: true, artifacts: "${test_name}/${test_name}_report.xml"
                                            junit testResults: "${test_name}/${test_name}_report.xml", keepLongStdio: true, allowEmptyResults: true
                                        }
                                    }
                                }
                            }
                        }
                    }

                    parallel(test_targets)
                }
            }
        }

        stage('Publish') {
            when {
                anyOf {
                    expression { return params.publish }
                }
                beforeAgent true
            }
            agent {
                label "linux && docker"
            }
            steps {
                script {
                    sh "make IS_PR_BUILD=${isPrBranch()} BUILD_NUMBER=${env.BUILD_ID} BUILD_BASE_NAME=${env.JOB_BASE_NAME} publish"
                }
            }
        }
    }
}

def isPrBranch() {
    return (env.CHANGE_BRANCH != null && env.CHANGE_BRANCH != '') ||
            (env.BRANCH_NAME != null && env.BRANCH_NAME.startsWith("PR-"))
}
